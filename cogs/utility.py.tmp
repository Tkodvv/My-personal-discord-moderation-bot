# -*- coding: utf-8 -*-
"""
Utility Cog
Contains utility commands like userinfo, avatar, server info, status lists, etc.
"""

import logging
import re
import asyncio
import math
import os
import aiohttp
import discord
from discord.ext import commands
from discord import app_commands
from discord.utils import utcnow, format_dt
from datetime import timedelta
from typing import Optional, List, Dict, Set

class UtilityCog(commands.Cog):
    """Utility commands cog."""

    def __init__(self, bot):
        self.bot = bot
        self.logger = logging.getLogger(__name__)
        self.start_time = bot.boot_time  # Use bot's boot time instead of creating new timestamp

        # message_id -> set(str(emoji)) allowed for polls
        self._poll_reaction_whitelist: Dict[int, Set[str]] = {}

    async def _send_command_response(self, ctx, content, *, ephemeral=False, delete_after=None):
        """Helper to send messages consistently across command types"""
        try:
            if isinstance(ctx, discord.Interaction):
                if not ctx.response.is_done():
                    await ctx.response.send_message(content, ephemeral=ephemeral)
                else:
                    await ctx.followup.send(content, ephemeral=ephemeral)
            else:
                await ctx.send(content, delete_after=delete_after)
        except Exception as e:
            self.logger.error(f"Error sending message: {e}")

    async def delete_command_message(self, ctx):
        """Helper to delete the command message for prefix commands."""
        if not isinstance(ctx, discord.Interaction) and hasattr(ctx, 'message'):
            try:
                await asyncio.sleep(0.1)  # Small delay to ensure message exists
                msg = ctx.message
                if msg:
                    try:
                        await msg.delete()
                    except (discord.NotFound, discord.Forbidden):
                        pass  # Message already deleted or no permissions
            except Exception as e:
                self.logger.warning(f"Failed to delete command message: {e}", exc_info=True)

    @commands.hybrid_command(name="cat", description="Send random cat image(s) (1–5)")
    @commands.cooldown(1, 5.0, commands.BucketType.user)
    @app_commands.describe(count="How many cats to fetch (1-5)")
    async def cat(self, ctx, count: Optional[int] = 1):
        """Send random cat image(s) (1–5)."""
        try:
            n = max(1, min(int(count or 1), 5))
        except (ValueError, TypeError):
            n = 1

        # Handle command type
        if isinstance(ctx, discord.Interaction):
            await ctx.response.defer(thinking=True)
        else:
            try:
                if hasattr(ctx, 'message'):
                    await asyncio.sleep(0.1)  # Small delay to ensure message exists
                    await ctx.message.delete()
            except Exception as e:
                self.logger.warning(f"Failed to delete command message: {e}")

        # Fetch cat images
        api_key = os.getenv("CAT_API_KEY")
        url = "https://api.thecatapi.com/v1/images/search"
        params = {"limit": n, "size": "full"}
        headers = {"x-api-key": api_key} if api_key else {}

        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url, params=params, headers=headers, timeout=15) as r:
                    if r.status != 200:
                        await self._send_command_response(ctx, "❌ Cat API error. Try again later.", ephemeral=True, delete_after=5)
                        return
                    data = await r.json()
        except Exception as e:
            self.logger.error(f"Cat API error: {e}")
            await self._send_command_response(ctx, "❌ Couldn't reach the cat server. Try again later.", ephemeral=True, delete_after=5)
            return

        if not isinstance(data, list) or not data:
            await self._send_command_response(ctx, "❌ No cats found.", ephemeral=True, delete_after=5)
            return

        sent_count = 0
        for item in data[:n]:
            img = item.get("url")
            if img:
                try:
                    await self._send_command_response(ctx, img)
                    sent_count += 1
                    await asyncio.sleep(0.5)  # Small delay between images
                except Exception as e:
                    self.logger.error(f"Error sending cat image: {e}")
                    continue

        if sent_count == 0:
            await self._send_command_response(ctx, "❌ Cat API returned no usable images.", ephemeral=True, delete_after=5)
